/*
- 객체
  소프트웨어 시스템 안의 어떠한 대상을 표현한 것
  - 정해진 처리를 수행함: 그 객체의 행위 / 메소드 / 멤버함수 라고 부른다.
  - 처리 과정에 따라 내부 상태가 변화할 수 있음: 내부 상태를 속성, 데이터 멤버 로 표현할 수 있다.
  - 다른 객체와 상호 작용을 할 수 있음: 상호작용을 메시지 전달(C++ 에서는 멤버 함수 호출이라고 함) 이라고 한다.


- 클래스
  - 객체의 설계도
  - 객체가 포함할 속성에 대한 명세와 메소드의 정의를 포함한다.


- 캡슐화 encapsulation
  - 객체 내부의 상세한 구현 부분과 외부 사용자의 관점을 분리해놓은 것이다.
    - 내부 속성 등 구현에 대한 부분은 공개하지 않으며(정보 은닉), 객체 외부에서는 공개된 인터페이스를 통해 객체를 사용할 수 있다.
    - 어떠한 대상의 복잡하고 어려운 부분, 사용자가 알지 못해도 되는 부분들은 감추어두고 꼭 알아야 하는 것만 공개하는 것이다.
      Eg. TV 를 시청하려면 TV의 동작 원리를 알아야하나?
          - TV를 구성하는 회로는 내부에 감추고 시청자는 외부에 마련된 조작 단추를 이용하여 TV를 시청한다.
          - 이 때 조작 단추를 인터페이스라고 한다.
          - 인터페이스를 통해 사용자가 TV 라는 복잡한 기기를 사용할 수 있게 된다.


- 캡슐화의 장점
  1. 소프트웨어의 유지보수가 용이하다.
     프로그램의 다른 부분에 영향을 미치지 않고 객체 내부 구현 방법을 수정할 수 있다.
  2. 재사용이 용이하다.
     잘 설계된 캡슐화 객체는 다른 응용에서도 재사용할 수 있어 소프트웨어 개발 비용을 줄일 수 있다.


- 클래스
  - 표현하고자 하는 대상의 메소드와 속성을 선언한 것.
  - 클래스
    1. 속성
       객체의 상태를 표현한다.
       C++ 에서는 데이터 멤버라고 부른다.
    2. 메소드
       객체의 행위를 정의한다.
       C++ 에서는 멤버 함수 라고 부른다.


- 클래스 선언문 형식
    Class ClassName {
        가시성_지시어_1:
            데이터 멤버 또는 멤버 함수 리스트;
        가시선_지시어_2:
            데이터 멤버 또는 멤버 함수 리스트;
        ...
    };


- 가시성 지시어
  - 클래스의 멤버가 공개되는 범위를 나타낸다.
  - 종류: private, public, protected
    1. private (디폴트)
       공개범위: - 소속 클래스의 멤버함수
                 - 친구 클래스의 멤버함수 및 친구함수
                 - 그 외 범위에는 비공개
       용도: - 정보 은닉을 위해 사용한다.
             - 클래스의 구현을 위한 내부 상태(데이터 멤버)는 일반적으로 private 으로 지정한다.
    2. public
       공개범위: - 전 범위
       용도: 주로 외부에 제공할 인터페이스를 공개하기 위해 사용한다.


- 기본 가시성
  - 클래스: 별도로 가시성을 지정하지 않으면 기본적으로 private
  - 구조체: 별도로 가시성을 지정하지 않으면 기본적으로 public


- 객체 정의 형식
  - 클래스이름 객체이름;
    ClassName objName;
  - 동일한 클래스의 객체를 여러개 생성하고 싶은 경우 클래스이름 객체이름1, 객체이름2;
    ClassName objName1, objName2, ... ;
    Eg. int main()
        {
            CircleClass c1, c2;
            .....
        }


- 객체 사용 형식
  - 객체 이름에 멤버 선택 연산자(.)를 사용하여 객체의 멤버를 액세스 함
    Eg. cin >> objName.dataMember;
        objName.memFunc( ... );
  - 객체의 멤버 함수 안에서 그 객체에 속한 멤버를 사용할 때는 멤버 이름만으로 액세스한다.
    Eg. class CircleClass 
        {
            C2dType center; // 중심좌표
            double radius; // 반지름
            public:
                ...
                bool chkOverlap(const CircleClass& c) const {
                    ...
                    return dCntr < radius + c.radius;
                    // 이 때 radius 는 c1 의 radius 이고 c.radius 는 인자값으로 넘어온 c2의 radius 이다.
                    // c1의 radius는 c1을 붙이지 않고 멤버 이름인 radius 만 사용한다. 
                }
        };
        int main() 
        {
            CircleClass c1, c2;
            ...
            if(c1.chkOverlap(c2)) {
            // c1 의 chkOverlap 함수임.
                ...
            }
        }

*/